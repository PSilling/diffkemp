//===------------- PatternComparator.h - Code pattern finder --------------===//
//
//       SimpLL - Program simplifier for analysis of semantic difference      //
//
// This file is published under Apache 2.0 license. See LICENSE for details.
// Author: Petr Silling, psilling@redhat.com
//===----------------------------------------------------------------------===//
///
/// \file
/// This file contains the implementation of the LLVM code pattern finder and
/// comparison manager, which enables eliminations of reports of known
/// module differences.
///
//===----------------------------------------------------------------------===//

#include "PatternComparator.h"
#include "Config.h"
#include "DifferentialFunctionComparator.h"
#include "Utils.h"

/// Tries to match a difference pattern starting with instructions that may
/// be matched to the given instruction pair. Returns true if a valid match
/// is found.
bool PatternComparator::matchPattern(const Instruction *InstL,
                                     const Instruction *InstR) {
    for (auto &&PatternFunCompPair : PatternFunComps) {
        auto PatternComps = &PatternFunCompPair.second;
        PatternComps->first->setStartInstruction(InstL);  // Left (old) side
        PatternComps->second->setStartInstruction(InstR); // Right (new) side

        // Compare the modules with patterns based on the given module
        // instruction pair.
        if (PatternComps->first->compare() == 0
            && PatternComps->second->compare() == 0) {
            if (!inputMappingValid(PatternFunCompPair.first, PatternComps)) {
                continue;
            }

            DEBUG_WITH_TYPE(DEBUG_SIMPLL,
                            dbgs() << getDebugIndent()
                                   << "Found a match for pattern "
                                   << PatternFunCompPair.first->Name << "\n");

            // Create a new instruction mapping since the match is valid.
            InstMappings.clear();
            processPatternMatch(PatternFunCompPair.first, PatternComps);
            return true;
        }
    }

    return false;
}

/// Check whether the input mapping generated by the given pattern function
/// comparator pair is valid even when both compared modules are analysed at
/// once.
bool PatternComparator::inputMappingValid(
        const Pattern *Pat, const PatternFunctionComparatorPair *PatternComps) {
    for (auto &&ArgPair : Pat->ArgumentMapping) {
        // Find the mapped values. Values that could not get matched during
        // pattern comparison will be found using module synchronization maps.
        // Input validity will be checked again for values obtained in this
        // manner.
        auto InputPairL =
                PatternComps->first->InputMatchMap.find(ArgPair.first);
        auto InputPairR =
                PatternComps->second->InputMatchMap.find(ArgPair.second);
        auto MapLE = PatternComps->first->InputMatchMap.end();
        auto MapRE = PatternComps->second->InputMatchMap.end();

        if (InputPairL != MapLE && InputPairR != MapRE) {
            if (DiffFunctionComp->cmpMappedValues(InputPairL->second,
                                                  InputPairR->second)) {
                return false;
            }
        } else if (InputPairL != MapLE) {
            auto MappedR =
                    DiffFunctionComp->getMappedValue(InputPairL->second, true);
            if (PatternComps->second->cmpInputValues(MappedR, ArgPair.second)) {
                return false;
            }
        } else if (InputPairR != MapRE) {
            auto MappedL =
                    DiffFunctionComp->getMappedValue(InputPairR->second, false);
            if (PatternComps->first->cmpInputValues(MappedL, ArgPair.first)) {
                return false;
            }
        }
    }

    return true;
}

/// Create the resulting instruction mapping and add all matched
/// instructions into the combined instruction set.
void PatternComparator::processPatternMatch(
        const Pattern *Pat, const PatternFunctionComparatorPair *PatternComps) {
    for (auto &&InstPair : PatternComps->first->InstMatchMap) {
        // Add the matched instruction into the set of matched instructions.
        AllInstMatches.insert(InstPair.second);

        // If the instruction is mapped, create the mapping as well.
        if (Pat->FinalMapping.find(InstPair.first) != Pat->FinalMapping.end()) {
            auto MappedInstR = Pat->FinalMapping[InstPair.first];
            auto MappedInstL = PatternComps->second->InstMatchMap[MappedInstR];
            InstMappings[MappedInstL] = InstPair.second;
        }
    }

    // Process the matched instructions from the second pattern side.
    for (auto &&InstPair : PatternComps->second->InstMatchMap) {
        AllInstMatches.insert(InstPair.second);
    }
}
